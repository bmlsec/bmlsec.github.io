---
layout: post
title: Roadmap for HackerOne private invitations
categories: [HackerOne, Hacker101, Burp, SqlMap]
---

![Hacker101 CTF](/images/h101ctf-1/Hacker101_CTF_Logo.png)

As far as I know off, the easiest way to earn some invitations for private programs on [HackerOne](https://www.hackerone.com/) is to complete several levels of [Hacker101 CTF](https://ctf.hacker101.com/ctf).

This is my way through the CTF, if you never heard of this, check [Hacker101](https://ctf.hacker101.com) website and start by taking a look at the [video section](https://www.hacker101.com/videos), a valuable resource.

You have to earn points by discovering flags at each level, for the first invitation you need to get 26 points... you can view the value for each flag and how many flags each level has:

![Flags points](/images/h101ctf-1/FlagPoints.png)

In the above picture you can see 2 red circles, meaning that the **Photo Gallery** level has 3 flags (2 already discovered) and each one gets you 6 points.

In this post I will walk you through my path for earning my first invitation, which involves solving the following levels:

* A little something to get you started
* Micro-CMS v1
* Micro-CMS v2
* Photo Gallery

__Note__: all flags from this blog post are not valid, you have to get your ones.

## A little something to get you started

### Flag 0

Accessing the page for this level, we get a page with just simple text... but if you look into the page source you'll see that it references an image for the background:

```html
<!doctype html>
<html>
	<head>
		<style>
			body {
				background-image: url("background.png");
			}
		</style>
	</head>
	<body>
		<p>Welcome to level 0.  Enjoy your stay.</p>
	</body>
</html>
```

Now you can right-click with the mouse and select **View Background Image** (I'm using Firefox):

![View Background Image](/images/h101ctf-1/ViewBackgroundImage.png)

or you can simply attach **/background.png** to the current URL in the browser, or even within a terminal using the **curl** command:
```
$ curl http://xxx.xxx.xxx.xxx/xxxxxxxxxx/background.png
^FLAG^1You0Have2Get7Your4One9Flag6This3Is2A7Dummy5One7Thanks7H101CTF91$FLAG$
```

**In Conclusion**, always dig into the page source looking for more information.

## Micro-CMS v1

There are several approaches one can take when starting with a fresh target, I tend to go with a recon, trying to understand what is the intended way of normal functioning for the site, and then I can try to break it.

### Recon

Clicking every link and filling every form with normal data, we can summarise the operations a user can make in the site, as follows:

* access the create page at /page/create
* access the page detail at /page/\<page id\>
* access the edit page at /page/edit/\<page id\>
* create a new page with 2 text fields (title and body)
* edit an existing page with 2 text fields (title and body)
* view all pages in the initial page
* both create and edit forms have support for [markdown](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet), but not for scripts

Now that we have collected all the necessary information, let's try to break it and get some flags.

### Flag 0

In the main page we can see text that is inputted by the user when creating or editing the page, let's check if we can reflect some HTML:

![Create new page](/images/h101ctf-1/Mv1_CreatePageHtml.png)

when we click the save button, there's a redirection to */page/\<page id\>* and the HTML is reflected:

![Page info](/images/h101ctf-1/Mv1_CreatePageHtmlResult.png)

How about we try some scripts by editing the page:

![Page info](/images/h101ctf-1/Mv1_EditPageScript.png)

hit save and...

![Page info](/images/h101ctf-1/Mv1_EditPageScriptResult.png)

no alert as intended... but, recalling your recon phase, there is another page that displays the data, the main page, could the behavior be different... try it!

And we have 2 alert windows, one for the script (we now know that the *title* is vulnerable to [Stored XSS](https://portswigger.net/web-security/cross-site-scripting/stored)) and another with the flag.

The flag would have appeared with just the first HTML payload, there was no need for the scripts, but this way you have a confirmation on what field is vulnerable and that there is, in fact, a vulnerability, because in the real world you’ll never have a popup with a flag...

You can also see the flag in the page source code:

```html
<!doctype html>
<html>
	<head>
		<title>Micro-CMS</title>
	</head>
	<body>
		<ul>
<li><a href="page/1">Testing</a></li>
<li><a href="page/2">Markdown Test</a></li>
<li><a href="page/13">test</a></li>
<li><a href="page/14"><script>alert("^FLAG^1You0Have2Get7Your4One9Flag6This3Is2A7Dummy5One7Thanks7H101CTF91$FLAG$"s);</script><script>alert('title')</script></a></li>
		</ul>
		<a href="page/create">Create a new page</a>
	</body>
</html>
```

### Flag 1

We have tampered with all user input fields to create and edit forms, but there are other inputs to tamper with... how about those *ids* passed in the URLs?... Let’s give it a try... what happens when we try a *page id* that does not exist?

From the recon phase, we have two places where we can insert an *id*:

* access the page detail at /page/\<page id\>
* access the edit page at /page/edit/\<page id\>

Let's try the first one (I'm using curl because it's easier for the post, tamper the URL in the browser instead, it's quicker):

```
$ curl http://xx.xx.xx.xx/xxxxxxxxx/page/3
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<title>404 Not Found</title>
<h1>Not Found</h1>
<p>The requested URL was not found on the server.  If you entered the URL manually please check your spelling and try again.</p>
```

You can try the edit page URL also, but the result is the same, a *Not Found*, meaning the *page id* doesn't exist. 

Now we can repeat the same URLs with an unexpected *page id* to see what happens... try a letter or a symbol instead of a number... what about a '(single quote)?... always the same *Not Found*... let's repeat all with the edit URL... and we have another flag!

### Flag 2

Have you noticed that there’s a void on *page ids*? We started with page id 1 and 2 (already existed on the main page) and then when we created a new page, the id was 13... another new page and the id was 14... what about ids between 2 and 13? We have already tried id 3 which gave us a *404 - Not Found* response... should we try the others?

You can use the browser, try one id at a time and see the response, or you can use a *bash shell script*:

```
$ for id in {3..12}; do echo 'Id: '$id && curl http://xx.xx.xx.xx/xxxxxxxx/page/$id; done
```

or [configure a Burp Intruder Attack](https://portswigger.net/support/configuring-a-burp-intruder-attack):

First, define the *id* as the position to fuzz:

![Configure intruder - Positions](/images/h101ctf-1/Mv1_PageIdIntruder1.png)

then configure the payload, we want just numbers from 1 to 14 (it's important to include a valid *id* to compare responses):

![Configure intruder - Payloads](/images/h101ctf-1/Mv1_PageIdIntruder2.png)

in the end we can see that there's an *id* with a different result from all the others... a *403 - Forbidden* on *page id* 6:

![Configure intruder - Results](/images/h101ctf-1/Mv1_PageIdIntruder3.png)

Ok, let's navigate to /page/6 in the browser and confirm that *403 - Forbidden* result.

How is this important? Now we have a forbidden page and we can try to access it. We can't use /page/6, but there is another way... try /page/edit/6...

**Note** that [Cody Brocious](https://twitter.com/daeken) made an awesome job with this CTF, and all the flags are generated for the specific user, so maybe other things can be dynamic, I'm not sure if the *page id* for you will be 6 or another number, bare that in mind.

### Flag 3

We have until now exploited the *page id*, the *title* in the create/edit page, what can we do more? Well, there is a *body* field that also allows user input... can it be vulnerable? It doesn't allow scripts, we've tried an alert via a script tag, but didn't work... but we can try other ways of injection script code besides script tags...

There are lots of HTML tags that allow for javascript execution, I've used this one:

![Img Tag Script](/images/h101ctf-1/Mv1_ImgTagScript.png)

After saving you'll get an alert window, but no visible flag... I was expecting a flag after this vulnerability... how come there's no flag?... then I went to view the page source code...

All flags for this level, continue to the next one.

**Conclusions:** reflection of user input can happen in several places, don't forget to check them all. If we stumble across an inaccessible resource, that is a great opportunity to recall your recon notes and see different places where you can access that resource.

## Micro-CMS v2

According to the changelog, this is version 2 of the previous level... I'm guessing it's to replicate a developer response to a report, resolving the reported vulnerabilities, but presenting new ones along the way... after all, no one is perfect.

Let's start all over again...

### Recon

It appears to have the same structure as before, but only admins can edit/create pages. 

There's also two new resources:

* /home
* /login

Even for more recon we have to be able to login as administrator or bypass the login altogether. Let's take a look at the login page.

### Flag 0

First, I always try credentials like blank fields, admin/admin, and other basic ones, but no luck here.

Notice that we have the message *Unknown user*... that's a good sign for us, it means that it differentiates between known users and non-existing ones. It could be handy for brute force attacks.

But first let's verify if it is vulnerable to [SQLi](https://portswigger.net/web-security/sql-injection)... try a '(single quote) as username and you'll get a pretty nice error:

```
Traceback (most recent call last):
  File "./main.py", line 145, in do_login
    if cur.execute('SELECT password FROM admins WHERE username=\'%s\'' % request.form['username'].replace('%', '%%')) == 0:
  File "/usr/local/lib/python2.7/site-packages/MySQLdb/cursors.py", line 255, in execute
    self.errorhandler(self, exc, value)
  File "/usr/local/lib/python2.7/site-packages/MySQLdb/connections.py", line 50, in defaulterrorhandler
    raise errorvalue
ProgrammingError: (1064, "You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near ''''' at line 1")
```

We have now confirmed that it is indeed vulnerable to SQLi and, even better, we have an additional data bonus, we know that it fetches the *password* column of *admins* table running on a *MariaDB server* using a python program.

The problem is, we don't know what user is administrator, I've tried *admin*, *administrator*, and others, but always the same error message indicating a non-existing user... 

So, we have to find a way of bypassing the login... let's start by attempting a [UNION attack](https://portswigger.net/web-security/sql-injection/union-attacks). We know that the code is fetching the *password* column, supposedly to compare it with the password field of the login page. What we can try is to force the result of the database operation to meet your inserted password... we can do a UNION forcing our chosen password to be retrieved back, like this:

```
' UNION SELECT 'pass' AS password FROM admins WHERE '1' = '1' #
```

If you put the above payload in the *user* field and a blank password, you'll get a new error *Invalid password*, meaning that the attack succeeded, it validated the user.

Now we have to match the *password* field with the password in the payload (I've used "pass", you can use whatever makes you happy).

We've bypassed the login and on the main page we have a private page with a flag.

It's now time for a new recon.

### Authenticated Recon

Navigate the site as an authenticated user and use it as intended. We have all the functionalities of the previous version, plus a new resource:

* /logout

### Flag 1

We can now replicate all previous attacks from version 1, but all the vulnerabilities are corrected. You can mess around with other payloads, maybe you get lucky, I didn't.

We can exploit further the new functionality, authentication. Can we do something that we are not allowed to, like create or edit a page? Start by logging out and then try to edit a page... we already know that it won't work, because we’ve tried it in the first recon... what can we do more?

We can modify the request method, instead of GET, use POST... intercept the request with Burp, right-click, and select *Change request method*:

![Burp change request method](/images/h101ctf-1/BurpChangeRequestMethod.png)

It will change GET to POST and you'll be happy with the result.

You can make your life easier and just use curl:

```
$ curl -X POST http://xx.xx.x.xx/xxxxxxxxx/page/edit/1
```

### Flag 2

For the next flag there's no way around it, we have to login with valid credentials. 

I did it using two different methods:

* Using Burp Intruder

You can launch a *Cluster bomb* attack, but it could take ages to run... so I used *Sniper* instead, to find out a valid *user*, then another run to find the *password* for that user. Of course this approach depends heavily on the wordlist you use... I used wordlists for common usernames and passwords from [SecLists](https://github.com/danielmiessler/SecLists) and got the credentials.

* Using sqlmap

Combining the information from the SQL error that we had previously, I executed this *sqlmap* command:
```
$ sqlmap -u http://xx.xx.x.xx/xxxxxxxx/login --method POST -T admins --data="username=&password=" --dump --dbms=mysql --skip-waf --threads 10 -o

[...]
Database: level2
Table: admins
[1 entry]
+------+----------+------------+
| id   | username | password   |
+------+----------+------------+
| 1    | grace    | maureen    |
+------+----------+------------+
```

I used these credentials and was rewarded with the last flag.

Once again, your valid credentials could be different.

Using sqlmap you can find the tables of the database and see the flag 1 in the *pages* table, but there's no need for that, unless you want to practice.

**Conclusions:** recon takes a crucial part in our success, and you should always check how the application behaves with authenticated and unauthenticated users, look for ways to access privileged resources that you shouldn't have access to. Changing request methods can lead to unexpected outcomes.

## Photo Gallery

I started with the recon, but it appears to be no functionality on this site... the page source code revealed an endpoint:

* /fetch?id=*\<photo id\>*

and that's it!

### Flag 0

I founded flag 1 first, but... let me keep on with flag 0.
Had no idea for this one, so I went for the *Hints*:

![Hints](/images/h101ctf-1/PG_Hints.png)

It became clear that I need to know how the system was mounted, so I google it and found this [Github page](https://github.com/tiangolo/uwsgi-nginx-flask-docker/tree/master/python3.7/app).

Ok, we know that it should exist at least 3 files in the system:

* main.py
* prestart.sh
* uwsgi.ini

and, somehow, it *hints* you on *union*... UNION attack? How? Well, the only parameter that we can use is the *photo id* parameter... and we are trying to access files on the system, so maybe this is a [Path traversal vulnerability](https://portswigger.net/web-security/file-path-traversal)... but how? It doesn't make sense... unless... unless the result form */fetch/id* is a path to the image, that makes sense... the path for the photos inside a database, accessed by photo id. In that case, we can assume that the query returns only one text column with the path.

We need to provide an invalid *photo id* because we don't want the image returned. I used Burp Repeater with the following payload:

```
4 UNION SELECT '../../../prestart.sh' #
```
and it worked!!!

![Burp Repeater](/images/h101ctf-1/PG_BurpRepeater.png)

I then tried with *main.py* and found the flag.

**Note:** if you use curl, don't forget to URL encode the payload:

```
$ curl "http://xx.xx.xx.xx/xxxxxxxx/fetch?id=4+UNION+SELECT+'../../../main.py'+%23"
```

### Flag 1

We know that *fetch/id* is vulnerable to SQLi... you can do some manual enumeration to find out more information, but we have it already because the *main.py* file showed us juicy information:

```
def getDb():
        return MySQLdb.connect(host="localhost", user="root", password="", db="level5")

cur.execute('SELECT id, title FROM albums')

cur.execute('SELECT id, title, filename FROM photos WHERE parent=%s LIMIT 3', (id, ))

if cur.execute('SELECT filename FROM photos WHERE id=%s' % request.args['id']) == 0:
```

It's now easy to provide this valuable information to sqlmap and hope for good results:

```
$ sqlmap -u "http://xx.xx.xx.xx/xxxxxxx/fetch?id=2" --method GET --dump -D level5 -T photos -p id --dbms=mysql --code 200 --skip-waf --random-agent --threads 10 -o

[...]
Database: level5
Table: photos
[3 entries]
+----+------------------+--------+------------------------------------------------------------------+
| id | title            | parent | filename                                                         |
+----+------------------+--------+------------------------------------------------------------------+
| 1  | Utterly adorable | 1      | files/adorable.jpg                                               |
| 2  | Purrfect         | 1      | files/purrfect.jpg                                               |
| 3  | Invisible        | 1      | 1You0Have2Get7Your4One9Flag6This3Is2A7Dummy5One7Thanks7H101CTF91 |
+----+------------------+--------+------------------------------------------------------------------+
```

That 64 character string for *Invisible* title sure looks like a flag...

**Conclusions:** sometimes you have to understand the system infrastructure to apply some attacks. And when we have access to files in the system, there could be valuable information lying around to be found...

### Flag 2

We don't need that right now, we have the points required for our first private invitation!

![Private invitation](/images/h101ctf-1/private_invitation_1.png)

I will continue from here to the next private invitation on a future post.

## Final thoughts

It was a lot of fun to do this CTF, I've learned a lot, hope you did too!

Take care! FOLLOW YOUR DREAMS!!!